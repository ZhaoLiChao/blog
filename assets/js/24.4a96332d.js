(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{213:function(a,r,e){"use strict";e.r(r);var t=e(0),n=Object(t.a)({},(function(){var a=this,r=a.$createElement,e=a._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("遍历(一)")]),a._v(" "),e("p",[a._v("这里总结的Array遍历方法有一个特点，"),e("strong",[a._v("callBack函数会为数组中的每个索引调用")]),a._v("，即从0到arr.length-1，而不仅仅是那些被赋值的索引，这意味着对于稀疏数组来说，该方法的效率要低于那些只遍历有值的索引的方法。")]),a._v(" "),e("h2",{attrs:{id:"array-prototype-find"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-find"}},[a._v("#")]),a._v(" "),e("strong",[a._v("Array.prototype.find()")])]),a._v(" "),e("p",[e("em",[a._v("find()方法返回数组中第一个满足测试函数(callback)的"),e("strong",[a._v("元素的值")]),a._v("(区别于findIndex返回元素的索引)，"),e("strong",[a._v("否则返回undefined")])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("arr.find(callBack[, thisArg])\n")])])]),e("ul",[e("li",[a._v("callBack：用于测试每个元素的函数，"),e("strong",[a._v("参数为(element, index, arr)")])]),a._v(" "),e("li",[a._v("thisArg：执行callBack时使用的this值")])]),a._v(" "),e("p",[a._v("描述：find()方法为数组中的每个元素执行一次callBack函数，直到找到一个使callBack返回true的元素。如果找到这个元素，那么find()方法立即返回这个元素的值；否则返回undefined；"),e("strong",[a._v("注意find()方法会遍历数组中的每一个元素，包括稀疏数组的empty slots！")])]),a._v(" "),e("p",[e("strong",[a._v("DEMO")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function isAnimal(item, index, arr){\n    return item.isAnimal;\n}\n\nvar arr = [\n    {name: 'Apple', isAnimal: false},\n    {name: 'Dog', isAnimal: true},\n    {name: 'Banana', isAnimal: false}\n]\nvar arr2 = [\n    {name: 'Apple', isAnimal: false},\n    {name: 'Orange', isAnimal: false},\n    {name: 'Banana', isAnimal: false}\n]\n\narr.find(isAnimal);//{name: 'Dog', isAnimal: true}\narr2.find(isAnimal);//undefined\n")])])]),e("h2",{attrs:{id:"array-prototype-findindex"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-findindex"}},[a._v("#")]),a._v(" "),e("strong",[a._v("Array.prototype.findIndex()")])]),a._v(" "),e("p",[e("em",[a._v("findIndex()方法返回数组中第一个满足测试函数(callback)的"),e("strong",[a._v("元素的索引")]),a._v("(区别于find返回元素的值)，"),e("strong",[a._v("否则返回-1")])])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("arr.findIndex(callBack[, thisArg])\n")])])]),e("ul",[e("li",[a._v("callBack：用于测试每个元素的函数，"),e("strong",[a._v("参数为(element, index, arr)")])]),a._v(" "),e("li",[a._v("thisArg：执行callBack时使用的this值")])]),a._v(" "),e("p",[a._v("描述：findIndex()方法为数组中的每个元素执行一次callBack函数，直到找到一个使callBack返回true的元素。如果找到这个元素，那么find()方法立即返回这个元素的索引；否则返回-1；"),e("strong",[a._v("注意findIndex()方法会遍历数组中的每一个元素，包括稀疏数组的empty slots！")])]),a._v(" "),e("p",[e("strong",[a._v("DEMO")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function isAnimal(item, index, arr){\n    return item.isAnimal;\n}\n\nvar arr = [\n    {name: 'Apple', isAnimal: false},\n    {name: 'Dog', isAnimal: true},\n    {name: 'Banana', isAnimal: false}\n]\nvar arr2 = [\n    {name: 'Apple', isAnimal: false},\n    {name: 'Orange', isAnimal: false},\n    {name: 'Banana', isAnimal: false}\n]\n\narr.findIndex(isAnimal);//1\narr2.findIndex(isAnimal);//-1\n")])])]),e("p",[a._v("遍历(二)")]),a._v(" "),e("p",[a._v("这篇笔记总结的Array遍历方法和上一篇相反，callBack函数只会为数组中被赋值的索引调用。"),e("strong",[a._v("那些已删除或者未初始化的项将被跳过(稀疏数组)")]),a._v("。这些方法的"),e("strong",[a._v("callBack函数在第一次调用时就已经确定了范围")]),a._v("。新增加的元素将不会被callBack访问到；若已经存在的元素被改变或者删除，则它们传递到callBack的值是遍历到它们的那一时刻的值，被删除的元素将不会被访问到。个人理解是在遍历开始时，"),e("strong",[a._v("索引已经确定")]),a._v("，之后每次遍历无论arr怎么变化，"),e("strong",[a._v("只会根据当前索引取当前arr的元素")]),a._v("。")]),a._v(" "),e("h2",{attrs:{id:"array-prototype-foreach"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-foreach"}},[a._v("#")]),a._v(" "),e("strong",[a._v("Array.prototype.forEach()")])]),a._v(" "),e("p",[e("em",[a._v("forEach()方法对数组的每个元素执行一次提供的函数")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("arr.forEach(callBack[, thisArg])\n")])])]),e("ul",[e("li",[a._v("callBack：用于测试每个元素的函数，"),e("strong",[a._v("参数为(element, index, arr)")])]),a._v(" "),e("li",[a._v("thisArg：执行callBack时使用的this值")])]),a._v(" "),e("p",[a._v("描述：forEach()方法为数组中含有效值的每一项执行一次callBack函数。")]),a._v(" "),e("p",[e("strong",[a._v("DEMO")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var arr = [1, , 2, 3];\n\n//跳过第二个索引处\narr.forEach((v, i) => {\n    console.log('第'+ (i + 1) + '个元素值为' + v);\n    //第1个元素值为1\n    //第3个元素值为2\n    //第4个元素值为3\n});\n\n//数组迭代时被修改，由于遍历已经确定范围，即索引不变\nvar numbers = [1, 2, 3, 4];\nnumbers.forEach((v, i) => {\n    console.log(v,i);\n    if(3 === v){\n        numbers.shift();\n        numbers.push(5);\n    }\n});\n//1 0\n//2 1\n//3 2\n//5 3\n")])])]),e("h2",{attrs:{id:"array-prototype-every"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-every"}},[a._v("#")]),a._v(" "),e("strong",[a._v("Array.prototype.every()")])]),a._v(" "),e("p",[e("em",[a._v("every()方法用于测试数组的所有元素是否都通过了指定函数的测试")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("arr.every(callBack[, thisArg])\n")])])]),e("ul",[e("li",[a._v("callBack：用于测试每个元素的函数，"),e("strong",[a._v("参数为(element, index, arr)")])]),a._v(" "),e("li",[a._v("thisArg：执行callBack时使用的this值")])]),a._v(" "),e("p",[a._v("描述：every()方法为数组中的每个元素执行一次callBack函数，直到找到一个使callBack返回false的元素。如果找到这个元素(返回值为false)，那么every()方法"),e("strong",[a._v("立即返回false,且不在执行之后的遍历")]),a._v("；否则every()方法返回true。")]),a._v(" "),e("p",[e("strong",[a._v("DEMO")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function isPositive(item, index, arr){\n    return item > 0;\n}\n\n[1, -1, 3, 0].every(isPositive);//false\n[7, 21, 5, 0.6].every(isPositive);//true\n")])])]),e("h2",{attrs:{id:"array-prototype-some"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-some"}},[a._v("#")]),a._v(" "),e("strong",[a._v("Array.prototype.some()")])]),a._v(" "),e("p",[e("em",[a._v("some()方法用于测试数组的某些元素是否都通过了指定函数的测试")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("arr.some(callBack[, thisArg])\n")])])]),e("ul",[e("li",[a._v("callBack：用于测试每个元素的函数，"),e("strong",[a._v("参数为(element, index, arr)")])]),a._v(" "),e("li",[a._v("thisArg：执行callBack时使用的this值")])]),a._v(" "),e("p",[a._v("描述：some()方法为数组中的每个元素执行一次callBack函数，直到找到一个使callBack返回true的元素。如果找到这个元素(返回值为true)，那么some()方法"),e("strong",[a._v("立即返回true,且不在执行之后的遍历")]),a._v("；否则some()方法返回false。")]),a._v(" "),e("p",[e("strong",[a._v("DEMO")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function isPositive(item, index, arr){\n    return item > 0;\n}\n\n[1, -1, 3, 0].some(isPositive);//true\n[-7, 0, -5, -8].some(isPositive);//false\n[7, 21, 5, 0.6].some(isPositive);//true\n")])])]),e("h2",{attrs:{id:"array-prototype-filter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-filter"}},[a._v("#")]),a._v(" "),e("strong",[a._v("Array.prototype.filter()")])]),a._v(" "),e("p",[e("em",[a._v("filter()方法创建了一个新数组，包含所有通过callBack函数测试的元素")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var newArray = oldArray.filter(callBack[, thisArg])\n")])])]),e("ul",[e("li",[a._v("callBack：用来测试数组的每个元素的函数，"),e("strong",[a._v("参数为(element, index, arr)")])]),a._v(" "),e("li",[a._v("thisArg：执行callBack时使用的this值")])]),a._v(" "),e("p",[a._v("描述：filter()方法为数组中的每个元素执行一次callBack函数，并将所有callBack返回true的元素创建一个新数组。")]),a._v(" "),e("p",[e("strong",[a._v("DEMO")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function positive(item, index, arr){\n    return item > 0;\n}\n\n[-21, -1, -3, 0].filter(positive);//[]\n[1, -1, 3, 0].filter(positive);//[1, 3]\n[7, 21, 5, 0.6].filter(positive);//[7, 21, 5, 0.6]\n")])])]),e("h2",{attrs:{id:"array-prototype-map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-map"}},[a._v("#")]),a._v(" "),e("strong",[a._v("Array.prototype.map()")])]),a._v(" "),e("p",[e("em",[a._v("map()方法创建了一个新数组，其结果是该数组中的每个元素调用一个提供的函数后返回的结果。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var newArray = oldArray.map(callBack[, thisArg])\n")])])]),e("ul",[e("li",[a._v("callBack：用来测试数组的每个元素的函数，"),e("strong",[a._v("参数为(element, index, arr)")])]),a._v(" "),e("li",[a._v("thisArg：执行callBack时使用的this值")])]),a._v(" "),e("p",[a._v("描述：map()方法为数组中的每个元素执行一次callBack函数，并将所有callBack的返回值(包括undefined)创建一个新数组。map()方法在处理数组时，"),e("strong",[a._v("数组元素的范围在callBack函数第一次调用就已经确定")]),a._v("。"),e("strong",[a._v("被删除的元素不会被访问，但是会返回undefined(empty slots)")]),a._v("。")]),a._v(" "),e("p",[e("strong",[a._v("DEMO")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var numbers = [1, 4, 9];\nnumbers.map(v => v * 2);\n//[2, 8, 18]\n\nvar words = ['a', , 'c', 'd'];\nwords.map(v => {\n    console.log(v);\n    return v;\n});\n//a\n//注意第二个索引出没有被遍历\n//c\n//d\n//虽然没有参与遍历，但是输出时以undefined(empty slots)作为结果\n//['a', undefined ×1, 'c', 'd']\n\n//字符反转\nvar str = 'Hello';\nArray.prototype.map.call(str,function(v){\n    return v;\n}).reverse().join('');\n//olleH\n")])])]),e("h2",{attrs:{id:"array-prototype-reduce"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-reduce"}},[a._v("#")]),a._v(" "),e("strong",[a._v("Array.prototype.reduce()")])]),a._v(" "),e("p",[e("em",[a._v("reduce()方法对累加器和数组中的每个元素(从左到右)应用一个函数，将其减少为单个值")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("arr.reduce(callBack[, initialValue])\n")])])]),e("ul",[e("li",[a._v("callBack：执行数组中每个值的函数，包含四个参数\n"),e("ul",[e("li",[a._v("accumulator：累加器累加回调的返回值；可以是上次回调后返回的累加值，或者是initialValue初始值。")]),a._v(" "),e("li",[a._v("currentValue：当前遍历元素的值")]),a._v(" "),e("li",[a._v("currentIndex：当前遍历元素的索引。"),e("strong",[a._v("如果提供了initialValue，则索引为0，否则从1开始计算。")])]),a._v(" "),e("li",[a._v("array：当前数组")])])]),a._v(" "),e("li",[a._v("initialValue：初始值，如果没有提供初始值，那么以第一个元素作为初始值。"),e("strong",[a._v("对于没有提供初始值的空数组，将抛出TypeError")]),a._v("。提供初始值通常更安全。")])]),a._v(" "),e("p",[e("strong",[a._v("DEMO")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[0, 1, 2, 3, 4].reduce((prev, curr) => prev + curr,5);\n//15\n\n[0, 1, 2, 3, 4].reduce((prev, curr) => prev - curr,5);\n//-5\n\n//二维数组转化为一维\n[[0, 1], [2, 3], [4, 5]].reduce((prev, curr) => {\n    return prev.concat(curr);\n    //return [...prev, ...curr];\n},[]);\n//[0, 1, 2, 3, 4, 5]\n")])])]),e("h2",{attrs:{id:"array-prototype-reduceright"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#array-prototype-reduceright"}},[a._v("#")]),a._v(" "),e("strong",[a._v("Array.prototype.reduceRight()")])]),a._v(" "),e("p",[e("em",[a._v("reduceRight()方法对累加器和数组中的每个元素(从右到左)应用一个函数，将其减少为单个值")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("arr.reduceRight(callBack[, initialValue])\n")])])]),e("ul",[e("li",[a._v("callBack：执行数组中每个值的函数，包含四个参数\n"),e("ul",[e("li",[a._v("accumulator：累加器累加回调的返回值；可以是上次回调后返回的累加值，或者是initialValue初始值。")]),a._v(" "),e("li",[a._v("currentValue：当前遍历元素的值")]),a._v(" "),e("li",[a._v("currentIndex：当前遍历元素的索引。"),e("strong",[a._v("如果提供了initialValue，则索引为最后一个元素的索引，否则从倒数第二个元素的索引开始计算。")])]),a._v(" "),e("li",[a._v("array：当前数组")])])]),a._v(" "),e("li",[a._v("initialValue：初始值，如果没有提供初始值，那么以最后一个元素作为初始值。"),e("strong",[a._v("对于没有提供初始值的空数组，将抛出TypeError")]),a._v("。提供初始值通常更安全。")])]),a._v(" "),e("p",[e("strong",[a._v("DEMO")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[0, 1, 2, 3, 4].reduceRight((prev, curr) => prev + curr,5);\n//15\n\n[0, 1, 2, 3, 4].reduceRight((prev, curr) => prev - curr,5);\n//-5\n\n//二维数组转化为一维\n[[0, 1], [2, 3], [4, 5]].reduceRight((prev, curr) => {\n    return prev.concat(curr);\n    //return [...prev, ...curr];\n},[]);\n//[4, 5, 2, 3, 0, 1]\n")])])])])}),[],!1,null,null,null);r.default=n.exports}}]);