(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{143:function(t,e,a){t.exports=a.p+"assets/img/react-redux-flow.ce8f9cb6.png"},144:function(t,e,a){t.exports=a.p+"assets/img/redux.a0cc576d.png"},179:function(t,e,a){"use strict";a.r(e);var r=a(0),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h4",{attrs:{id:"_1-为什么要使用-redux-？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么要使用-redux-？"}},[t._v("#")]),t._v(" 1. 为什么要使用 Redux ？")]),t._v(" "),r("ul",[r("li",[t._v("随着 JavaScript 单页应用开发日趋复杂,管理不断变化的 state 非常困难")]),t._v(" "),r("li",[t._v("Redux的出现就是为了解决state里的数据问题")]),t._v(" "),r("li",[t._v("在React中，数据在组件中是单向流动的")]),t._v(" "),r("li",[t._v("数据从一个方向父组件流向子组件(通过props)，由于这个特征，两个非父子关系的组件（或者称作兄弟组件）之间的通信就比较麻烦")]),t._v(" "),r("li",[r("strong",[t._v("注意：redux在您的应用中并不是必要的！如果您的应用数据比较简单，redux的加入会使您的开发变得更为困难！！！")]),t._v(" "),r("img",{attrs:{src:a(143),alt:"react数据量和redux数据量"}})])]),t._v(" "),r("h4",{attrs:{id:"_2-redux设计思想"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-redux设计思想"}},[t._v("#")]),t._v(" 2. Redux设计思想")]),t._v(" "),r("ul",[r("li",[t._v("Redux是将整个应用状态存储到到一个地方，称为store")]),t._v(" "),r("li",[t._v("里面保存一棵状态树state tree")]),t._v(" "),r("li",[t._v("组件可以派发dispatch行为，将要改变的值通过action给store，而不是直接通知其它组件")]),t._v(" "),r("li",[t._v("其它组件可以通过订阅store中的状态(state)来刷新自己的视图\n"),r("img",{attrs:{src:a(144),alt:"react数据量和redux数据量"}})])]),t._v(" "),r("p",[r("strong",[t._v("总结Redux工作流程：")]),t._v(" 用户在component中dispatch一个action，store就会根据action自动触发一个reducers，reducers会接受两个参数（旧state，action）并根据action的type属性得到一个新的state（注意：redrcers是一个纯函数）；store得到新的state后会调用用户定义的监听函数，从而更新component。")]),t._v(" "),r("h4",{attrs:{id:"_3-redux三大原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-redux三大原则"}},[t._v("#")]),t._v(" 3. Redux三大原则")]),t._v(" "),r("ul",[r("li",[t._v("整个应用的 state 被储存在一棵 object tree 中，并且是唯一的")]),t._v(" "),r("li",[t._v("State 是只读的，惟一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象 使用纯函数来执行修改，为了描述action如何改变state tree ，你需要编写 reducers")]),t._v(" "),r("li",[t._v("单一数据源的设计让React的组件之间的通信更加方便，同时也便于状态的统一管理")])]),t._v(" "),r("h4",{attrs:{id:"_4-你可能不需要-redux"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-你可能不需要-redux"}},[t._v("#")]),t._v(" 4. 你可能不需要 Redux")]),t._v(" "),r("p",[t._v("首先明确一点，Redux 是一个有用的架构，但不是非用不可。事实上，大多数情况，你可以不用它，只用 React 就够了。"),r("br"),t._v("\n简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。\n从组件角度看，如果你的应用有以下场景，可以考虑使用 Redux：")]),t._v(" "),r("ul",[r("li",[t._v("某个组件的状态，需要共享")]),t._v(" "),r("li",[t._v("某个状态需要在任何地方都可以拿到")]),t._v(" "),r("li",[t._v("一个组件需要改变全局状态")]),t._v(" "),r("li",[t._v("一个组件需要改变另一个组件的状态")])]),t._v(" "),r("h4",{attrs:{id:"_5-总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-总结"}},[t._v("#")]),t._v(" 5. 总结")]),t._v(" "),r("ul",[r("li",[t._v("store在整个应用中是唯一的")]),t._v(" "),r("li",[t._v("store里面的state不能被直接修改，只有通过dispatch 一个 action 去修改")]),t._v(" "),r("li",[r("strong",[t._v("action一般至少包含两个属性：type: 触发什么操作（对应reducer）；payload：新的state的值")]),r("br"),t._v("\n即： action = {type: 'XXX', payload: value}")])])])}),[],!1,null,null,null);e.default=s.exports}}]);