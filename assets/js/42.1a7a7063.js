(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{194:function(t,a,s){"use strict";s.r(a);var e=s(0),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"vue面试题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue面试题"}},[t._v("#")]),t._v(" vue面试题")]),t._v(" "),s("h3",{attrs:{id:"_1-vue的响应式原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue的响应式原理"}},[t._v("#")]),t._v(" 1. vue的响应式原理")]),t._v(" "),s("p",[t._v("vue 实现数据双向绑定主要是：采用数据劫持结合“发布者 - 订阅者”模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter、 getter，在数据变动时发布消息给订阅者，触发相应监听回调。也就是：")]),t._v(" "),s("ul",[s("li",[t._v("实现一个监听器Observe，用来接触并监听所有属性，如果属性有变动，就通知订阅者")]),t._v(" "),s("li",[t._v("实现一个订阅者Watcher，可以收到属性的变化并通知执行响应的回调函数，从而更新视图")])]),t._v(" "),s("p",[s("strong",[t._v("扩展：Vue的Watcher有三种")])]),t._v(" "),s("ul",[s("li",[t._v("内部使用的Watcher")]),t._v(" "),s("li",[t._v("用户自定义的watch，使用"),s("code",[t._v("{user: true}")]),t._v("标识")]),t._v(" "),s("li",[t._v("用户定义的computed，使用"),s("code",[t._v("{lazy: true}")]),t._v("标识")])]),t._v(" "),s("p",[s("strong",[t._v("扩展：watch和computed\b内部其实也是调用的Watcher：")])]),t._v(" "),s("ul",[s("li",[t._v("watch 会在初始化渲染Watcher执行一次，保存oldValue(如果没有，则为undefined)；监听的属性变化后，再次执行Watcher，得到newValue；执行用户定义的callback，并将 newValue, oldValue 做为实参传入")]),t._v(" "),s("li",[t._v("computed\b 并不会理解执行，它将在模板解析到的时候执行。它内部使用darty(脏值检查，默认为true)，在取值后值为false；如果修改关联的属性值，会将darty值为true，\b从而对computed重新取值，更新视图！")])]),t._v(" "),s("h3",{attrs:{id:"_2-计算属性-computed-和事件-methods-有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-计算属性-computed-和事件-methods-有什么区别"}},[t._v("#")]),t._v(" 2. 计算属性 computed 和事件 methods 有什么区别")]),t._v(" "),s("p",[t._v("我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的。即 "),s("strong",[t._v("在一定程度上（简单逻辑的情况下）可以达到相同的结果")])]),t._v(" "),s("ul",[s("li",[t._v("computed：计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值。（内部使用了darty）")]),t._v(" "),s("li",[t._v("method：只要发生重新渲染， method 调用总会执行该函数。")]),t._v(" "),s("li",[t._v("所以，method 可能会比 computed 执行更多次")])]),t._v(" "),s("h3",{attrs:{id:"_3-vue-的核心是什么？有什么优缺点？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue-的核心是什么？有什么优缺点？"}},[t._v("#")]),t._v(" 3. Vue 的核心是什么？有什么优缺点？")]),t._v(" "),s("p",[t._v("\b核心：数据驱动、组件系统\n优点：")]),t._v(" "),s("ul",[s("li",[t._v("良好的交互体验")]),t._v(" "),s("li",[t._v("良好的前后端工作分离模式  => MVVM，其实是将传统的MVC中的V(view)层拆分出来的")]),t._v(" "),s("li",[t._v("减轻服务器压力\n缺点：")]),t._v(" "),s("li",[t._v("SEO 难度较高")]),t._v(" "),s("li",[t._v("前进、后退管理")]),t._v(" "),s("li",[t._v("初次加载耗时多 => 递归遍历data，做响应式")])]),t._v(" "),s("h3",{attrs:{id:"_4-nexttick-是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-nexttick-是什么"}},[t._v("#")]),t._v(" 4. NextTick 是什么")]),t._v(" "),s("p",[t._v("nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。")]),t._v(" "),s("p",[t._v("实现原理："),s("strong",[t._v("任务队列（即使用定时器，做到同步执行完成后再执行）")])]),t._v(" "),s("p",[t._v("异步是分执行顺序的:"),s("br"),t._v("\n会先执行微任务：promise  mutationObserver)"),s("br"),t._v("\n再执行宏任务：setImmediate  setTimeout"),s("br"),t._v("\n内部使用if依次判断浏览器内部是否支持，如果支持，立刻使用。因为定时器最慢，而为了性能，尽可能的早执行！！！")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextTick")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("cb")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// cb就是flushQueue")]),t._v("\n    callbacks"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("push")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("cb"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 要异步刷新这个callbacks ，获取一个异步的方法 ")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//                          微任务                       宏任务")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 异步是分执行顺序的 会先执行(promise  mutationObserver)  setImmediate  setTimeout ")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("timerFunc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("flushCallbacks")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Promise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// then方法是异步的")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" Promise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("resolve")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("timerFunc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MutationObserver"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// MutationObserver 也是一个异步方法")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" observe "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MutationObserver")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("timerFunc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// H5的api")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" textNode "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createTextNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        observe"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("textNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("characterData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        textNode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("textContent "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("setImmediate"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setImmediate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("timerFunc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("timerFunc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h3",{attrs:{id:"_5-对比-jquery-，vue-有什么不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-对比-jquery-，vue-有什么不同"}},[t._v("#")]),t._v(" 5. 对比 jQuery ，Vue 有什么不同")]),t._v(" "),s("p",[t._v("jQuery 专注视图层，通过操作 DOM 去实现页面的一些逻辑渲染； Vue 专注于数据层，通过数据的双向绑定，最终表现在 DOM 层面，减少了 DOM 操作。\nVue 使用了组件化思想，使得项目子集职责清晰，提高了开发效率，方便重复利用，便于协同开发。")]),t._v(" "),s("h3",{attrs:{id:"_6-vue-生命周期的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue-生命周期的理解"}},[t._v("#")]),t._v(" 6. Vue 生命周期的理解")]),t._v(" "),s("ul",[s("li",[t._v("beforeCreated()：在实例创建之间执行，数据未加载状态。")]),t._v(" "),s("li",[t._v("created()：在实例创建、数据加载后，能初始化数据，DOM 渲染之前执行。")]),t._v(" "),s("li",[t._v("beforeMount()：虚拟 DOM 已创建完成，在数据渲染前最后一次更改数据。")]),t._v(" "),s("li",[t._v("mounted()：页面、数据渲染完成，真实 DOM 挂载完成。")]),t._v(" "),s("li",[t._v("beforeUpadate()：重新渲染之前触发。")]),t._v(" "),s("li",[t._v("updated()：数据已经更改完成，DOM 也重新 render 完成，更改数据会陷入死循环。")]),t._v(" "),s("li",[t._v("beforeDestory() 和 destoryed()：前者是销毁前执行（实例仍然完全可用），后者则是销毁后执行。")])]),t._v(" "),s("h3",{attrs:{id:"_7-父子组件通信的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-父子组件通信的方式"}},[t._v("#")]),t._v(" 7. 父子组件通信的方式")]),t._v(" "),s("ul",[s("li",[t._v("props & $emit")]),t._v(" "),s("li",[s("code",[t._v("$parent & $children")])]),t._v(" "),s("li",[s("code",[t._v("$attrs & $listeners")])]),t._v(" "),s("li",[t._v("Provide & Inject")]),t._v(" "),s("li",[t._v("Ref")]),t._v(" "),s("li",[t._v("EventBus")])]),t._v(" "),s("h3",{attrs:{id:"_8-vue-router-实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue-router-实现原理"}},[t._v("#")]),t._v(" 8. vue-router 实现原理")]),t._v(" "),s("h5",{attrs:{id:"是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#是什么？"}},[t._v("#")]),t._v(" 是什么？")]),t._v(" "),s("p",[t._v("路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。")]),t._v(" "),s("h5",{attrs:{id:"实现原理？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现原理？"}},[t._v("#")]),t._v(" 实现原理？")]),t._v(" "),s("p",[t._v("vue-router有两种模式：hash 和 history 两种实现方式")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("hash 模式实现原理\n通过 hashchange 事件监听 URL 的变化，改变 URL 的方式只有这几种：通过浏览器前进后退改变 URL、通过a标签改变 URL、通过window.location改变URL，这几种情况改变 URL 都会触发 hashchange 事件")])]),t._v(" "),s("li",[s("p",[t._v("history 模式实现原理\nhistory 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新"),s("br"),t._v("\nhistory 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或a标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和a标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。")])])]),t._v(" "),s("h5",{attrs:{id:"vue-如何去除-url-中的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-如何去除-url-中的"}},[t._v("#")]),t._v(" Vue 如何去除 URL 中的#")]),t._v(" "),s("p",[t._v("vue-router 默认使用 hash 模式，所以在路由加载的时候，项目中的 URL 会自带 “#”。如果不想使用 “#”， 可以使用 vue-router 的另一种模式 history：")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Router")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  mode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'history'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  routes"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("需要注意的是，当我们启用 history 模式的时候，由于我们的项目是一个单页面应用，所以在路由跳转的时候，就会出现访问不到静态资源而出现 “404” 的情况，这时候就需要服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 “index.html” 页面。")]),t._v(" "),s("h4",{attrs:{id:"_9-vue项目优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue项目优化"}},[t._v("#")]),t._v(" 9. vue项目优化")]),t._v(" "),s("ul",[s("li",[t._v("减少http")]),t._v(" "),s("li",[t._v("减少DOM操作")]),t._v(" "),s("li",[t._v("关闭sourceMap")]),t._v(" "),s("li",[t._v("使用 externals(忽略列表) + cdn")]),t._v(" "),s("li",[t._v("路由懒加载")]),t._v(" "),s("li",[t._v("合理利用v-if和v-show")]),t._v(" "),s("li",[t._v("正确使用 key，避免错误渲染")]),t._v(" "),s("li",[t._v("正确定义响应式数据，使用Object.freeze")])]),t._v(" "),s("h4",{attrs:{id:"_10-vue3-0-中的-proxy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue3-0-中的-proxy"}},[t._v("#")]),t._v(" 10. vue3.0 中的 Proxy")]),t._v(" "),s("ul",[s("li",[s("ol",[s("li",[t._v("是什么？"),s("br"),t._v("\n可以理解为在对象之前设置一个“拦截”，当该对象被访问的时候，都必须经过这层拦截。意味着你可以在这层拦截中进行各种操作。比如你可以在这层拦截中对原对象进行处理，返回你想返回的数据结构。")])])]),t._v(" "),s("li",[s("ol",{attrs:{start:"2"}},[s("li",[t._v('为什么比 defineProperty 更好\n主要是因为Proxy是拦截对象，对对象进行一个"拦截"，外界对该对象的访问，都必须先通过这层拦截。无论访问对象的什么属性，之前定义的还是新增的，它都会走到拦截中。'),s("br"),t._v("\n而 defineProperty 会递归遍历属于的数据，并且还重写了数组方法。")])])])])])}),[],!1,null,null,null);a.default=n.exports}}]);